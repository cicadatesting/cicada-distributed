from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any, Callable, Dict, List, Optional, Tuple

from pydantic.main import BaseModel


class Result(BaseModel):
    """Result generated by a user or scenario."""

    id: Optional[str]
    output: Optional[Any]
    exception: Optional[Any]
    logs: Optional[str]
    timestamp: Optional[datetime]
    time_taken: Optional[int]

    class Config:
        """Encode class as JSON."""

        json_encoders = {
            Exception: lambda e: str(e),
        }


class IScenarioCommands(ABC):
    """Interface to decouple scenario commands from scenario."""

    @property
    @abstractmethod
    def aggregated_results(self) -> Any:
        """Get result based on all results gathered from users."""
        pass

    @aggregated_results.setter
    def aggregated_results(self, val: Any):
        pass

    @property
    @abstractmethod
    def num_users(self) -> int:
        """Get number of users currently running in scenario."""
        pass

    @property
    @abstractmethod
    def num_results_collected(self) -> int:
        """Get number of results collected from users."""
        pass

    @property
    @abstractmethod
    def errors(self) -> List[str]:
        """List of errors reported by users."""
        pass

    @abstractmethod
    def scale_users(self, n: int):
        """Change number of running users.

        Args:
            n (int): Desired number of users
        """

    @abstractmethod
    def start_users(self, n: int):
        """Start users for a scenario.

        Args:
            n (int): number of users to start
        """
        pass

    @abstractmethod
    def stop_users(self, n: int):
        """Stop users for a scenario.

        Args:
            n (int): number of users to stop
        """
        pass

    @abstractmethod
    def add_work(self, n: int):
        """Distribute work (iterations) to all users in scenario.

        Args:
            n (int): Amount of work to distribute across user pool
        """
        pass

    @abstractmethod
    def send_user_events(self, kind: str, payload: dict):
        """Send an event to all user in the user pool.

        Args:
            kind (str): Type of event
            payload (dict): JSON dict to send to user
        """

    @abstractmethod
    def get_latest_results(
        self,
        timeout_ms: Optional[int] = 1000,
        limit: int = 500,
    ) -> List[Result]:
        """Gathers results produced by users.

        Args:
            timeout_ms (int, optional): Time to wait for results. Defaults to 1000.
            limit (int): Max results to return. Defaults to 500

        Returns:
            List[Result]: List of latest results collected
        """

    @abstractmethod
    def aggregate_results(self, latest_results: List[Result]) -> Any:
        """Run scenario aggregator function against latest gathered results and
        save aggregate.

        Args:
            latest_results (List[Result]): Results to run aggregator function on

        Returns:
            Any: Result of scenario aggregator function
        """

    @abstractmethod
    def verify_results(self, latest_results: List[Result]) -> Optional[List[str]]:
        """Run scenario result verification function against latest results.

        Args:
            latest_results (List[Result]): Last results to be collected

        Returns:
            Optional[List[str]]: List of error strings gathered for scenario
        """

    @abstractmethod
    def collect_metrics(self, latest_results: List[Result]):
        """Parse latest results and save metrics if any can be parsed from result set.

        Args:
            latest_results (List[Result]): List of latest collected results
        """


class IUserCommands(ABC):
    """Interface to decouple user commands from scenario."""

    @property
    @abstractmethod
    def available_work(self) -> int:
        """Get amount of work available to user."""
        pass

    @abstractmethod
    def is_up(self) -> bool:
        """Check if user is still running.

        Returns:
            bool: User is up
        """

    @abstractmethod
    def has_work(self, timeout_ms: Optional[int] = 1000) -> bool:
        """Check if user has remaining invocations.

        Args:
            timeout_ms (int, optional): Time to wait for work event to appear before returning. Defaults to 1000.

        Returns:
            bool: User has work
        """

    @abstractmethod
    def run(self, *args, log_traceback=True, **kwargs) -> Tuple[Any, Exception, str]:
        """Run scenario function with arguments; capture exception and logs.

        Args:
            log_traceback (bool, optional): Print out traceback for exception. Defaults to True.

        Returns:
            Tuple[Any, Exception, str]: Output, exception, and logs captured
        """

    @abstractmethod
    def report_result(
        self, output: Any, exception: Any, logs: Optional[str], time_taken: int
    ):
        """Report result for scenario invocation from user to scenario.

        Args:
            output (Any): Function output
            exception (Any): Function exception
            logs (Optional[str]): Function logs
            time_taken (int): Time taken in seconds to call function once
        """


UserLoopFn = Callable[[IUserCommands, dict], None]
LoadModelFn = Callable[[IScenarioCommands, dict], Any]
ResultAggregatorFn = Callable[[Optional[Any], List[Result]], Any]
ResultVerifierFn = Callable[[List[Result]], List[str]]
OutputTransformerFn = Callable[[Optional[Any]], Any]
MetricCollector = Callable[[List[Result], IScenarioCommands], None]
ConsoleMetricDisplays = Dict[str, Callable[[str, str, str], Optional[str]]]
